<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bruno Gondim Toledo">
<meta name="dcterms.date" content="2024-12-16">

<title>Bruno Gondim - Processos de Poisson não homogêneos de n tipos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../cup-hot" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Bruno Gondim - Processos de Poisson não homogêneos de n tipos">
<meta property="og:description" content="O presente trabalho foi apresentado na disciplina de Processos estocásticos do bacharel de Estatística da Universidade de Brasília ministrada pela Prof.ª Dr.ª Cira Etheowalda Guevara Otiniano no 1º semestre de 2024, com objetivo responder a seguinte pergunta: “Quantos processos serão julgados em um determinado tribunal em um ano?”. Modelar quantidade de processos julgados pode ser relevante para, por exemplo, estimar custos, número de funcionários necessários, possível expansão ou diminuição do tribunal em função desta produtividade. Para responder esta pergunta, modelou-se uma soma de processos de Poisson não homogêneos.">
<meta property="og:site_name" content="Bruno Gondim">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../cup-hot" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bruno Gondim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-presentations" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Presentations</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-presentations">    
        <li>
    <a class="dropdown-item" href="../../presentations/nlp/index.html">
 <span class="dropdown-text">Agrupador de processos de controle concentrado</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../presentations/random_forest/apresentacao.html">
 <span class="dropdown-text">Técnicas de Random Forest em árvores de decisão</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../presentations/estocasticos/estocasticos.html">
 <span class="dropdown-text">Processos de Poisson não homogêneos de n tipos</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools tools-wide">
    <a href="https://www.linkedin.com/in/bruno-gondim/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-linkedin"></i></a>
    <a href="https://github.com/penasta" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
    <a href="mailto:brunogtoledo96@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-mailbox"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introdução" id="toc-introdução" class="nav-link active" data-scroll-target="#introdução">Introdução</a></li>
  <li><a href="#metodologia" id="toc-metodologia" class="nav-link" data-scroll-target="#metodologia">Metodologia</a>
  <ul class="collapse">
  <li><a href="#dia-útil" id="toc-dia-útil" class="nav-link" data-scroll-target="#dia-útil">Dia útil</a></li>
  <li><a href="#processo-de-contagem" id="toc-processo-de-contagem" class="nav-link" data-scroll-target="#processo-de-contagem">Processo de contagem</a></li>
  <li><a href="#variável-aleatória-poisson" id="toc-variável-aleatória-poisson" class="nav-link" data-scroll-target="#variável-aleatória-poisson">Variável aleatória Poisson</a></li>
  <li><a href="#processo-de-poisson" id="toc-processo-de-poisson" class="nav-link" data-scroll-target="#processo-de-poisson">Processo de Poisson</a>
  <ul class="collapse">
  <li><a href="#processo-de-poisson-homogêneo" id="toc-processo-de-poisson-homogêneo" class="nav-link" data-scroll-target="#processo-de-poisson-homogêneo">Processo de Poisson homogêneo</a></li>
  <li><a href="#processo-de-poisson-não-homogêneo" id="toc-processo-de-poisson-não-homogêneo" class="nav-link" data-scroll-target="#processo-de-poisson-não-homogêneo">Processo de Poisson não homogêneo</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#análises" id="toc-análises" class="nav-link" data-scroll-target="#análises">Análises</a>
  <ul class="collapse">
  <li><a href="#quantos-processos-são-julgados-por-um-juiz-em-um-mês" id="toc-quantos-processos-são-julgados-por-um-juiz-em-um-mês" class="nav-link" data-scroll-target="#quantos-processos-são-julgados-por-um-juiz-em-um-mês">Quantos processos são julgados por um juiz em um mês?</a></li>
  <li><a href="#quantos-processos-são-julgados-por-um-juíz-em-um-ano" id="toc-quantos-processos-são-julgados-por-um-juíz-em-um-ano" class="nav-link" data-scroll-target="#quantos-processos-são-julgados-por-um-juíz-em-um-ano">Quantos processos são julgados por um juíz em um ano?</a></li>
  <li><a href="#quantos-processos-são-julgados-em-um-tribunal-em-um-ano" id="toc-quantos-processos-são-julgados-em-um-tribunal-em-um-ano" class="nav-link" data-scroll-target="#quantos-processos-são-julgados-em-um-tribunal-em-um-ano">Quantos processos são julgados em um tribunal em um ano?</a></li>
  </ul></li>
  <li><a href="#aplicação-computacional" id="toc-aplicação-computacional" class="nav-link" data-scroll-target="#aplicação-computacional">Aplicação computacional</a></li>
  <li><a href="#resultados" id="toc-resultados" class="nav-link" data-scroll-target="#resultados">Resultados</a></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">Conclusão</a>
  <ul class="collapse">
  <li><a href="#referências" id="toc-referências" class="nav-link" data-scroll-target="#referências">Referências</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Processos de Poisson não homogêneos de n tipos</h1>
<p class="subtitle lead">Uma possível aplicação no poder Judiciário</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://github.com/penasta">Bruno Gondim Toledo</a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Universidade de Brasília - UnB
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 16, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    O presente trabalho foi apresentado na disciplina de Processos estocásticos do bacharel de Estatística da Universidade de Brasília ministrada pela Prof.ª Dr.ª Cira Etheowalda Guevara Otiniano no 1º semestre de 2024, com objetivo responder a seguinte pergunta: “Quantos processos serão julgados em um determinado tribunal em um ano?”. Modelar quantidade de processos julgados pode ser relevante para, por exemplo, estimar custos, número de funcionários necessários, possível expansão ou diminuição do tribunal em função desta produtividade. Para responder esta pergunta, modelou-se uma soma de processos de Poisson não homogêneos.
  </div>
</div>


</header>


<section id="introdução" class="level1">
<h1>Introdução</h1>
<p>Modelagem de dados e previsão de eventos futuros tem sido o garantidor do mercado de trabalho em estatística estar aquecido. Este tipo de inteligência aplicada à negócios vem se tornando essencial em qualquer setor, inclusive no poder Judiciário. Apesar deste não depender de faturamento para sua existência por ser inalienável ao setor público, tem sido do interesse dos próprios tribunais saber indicadores e estatísticas relacionadas ao próprio tribunal. E a modelagem surge neste contexto para agregar valor às decisões estratégicas deste poder.</p>
<p>Buscou-se trabalhos de temas semelhantes, que visam modelar a quantidade de decisões em processos em tribunais. Entretanto, não consegui localizar nenhum; motivo esse talvez por ser tema sensível, no sentido de poder levar indiretamente a comparação de rendimentos entre juízes em um tribunal, seja pela possível falta de pertinência do assunto, seja pela tentativa inédita de modelar algo do tipo.</p>
<p>Entretando, buscou-se trabalhos que modelam outros tipos de contagem usando de processo de Poisson não homogêneo, como (DINCER;DEMIR;YALÇIN,2022).</p>
<p>Na metodologia, com base no livro ROSS (2010), apresento toda a metodologia e suporte teórico adotado na seção de análises. Na seção aplicação computacional iremos trazer uma possível solução simulada do problema proposto, e na seção de resultados apresento as conclusões gerais.</p>
<hr>
</section>
<section id="metodologia" class="level1">
<h1>Metodologia</h1>
<p>Irei trazer em tópicos as tecnologias utilizadas diretamente no trabalho. Para mais informações, consulte ROSS (2010) cap. 5.3.</p>
<section id="dia-útil" class="level2">
<h2 class="anchored" data-anchor-id="dia-útil">Dia útil</h2>
<p>Por mais hiperbólico que pareça, não foi possível localizar uma definição fechada de dia útil. Portanto, consideraremos como dia útil, todos os dias do ano excetuado os feriados, finais de semana (sábado e domingo) e recessos coletivos. Pegando como base o ano de 2023, iríamos considerar como dia útil para o tribunal selecionado para a aplicação computacional todos os dias com excessão de:</p>
<ul>
<li>Todos os sábados e todos os domingos do ano;</li>
<li>Dias 01/01/2023 a 06/01/2023 - Recesso Forense;</li>
<li>Dias 20/02/2023 a 22/02/2023 - Carnaval &amp; quarta-feira de cinzas;</li>
<li>Dias 5/04/2023 a 7/04/2023 - Quarta e quinta-feira Santa e Paixão de Cristo;</li>
<li>Dia 21/04/2023 - Tiradentes;</li>
<li>Dia 1/05/2023 - Dia do trabalhador;</li>
<li>Dia 08/06/2023 - Corpus Christi;</li>
<li>Dia 11/08/2023 - Dia do Advogado;</li>
<li>Dia 7/09/2023 - Independência;</li>
<li>Dia 12/10/2023 - Dia de Nossa Senhora Aparecida;</li>
<li>Dias 01/11/2023 e 02/11/2023 - Dia de Todos os Santos e Finados;</li>
<li>Dia 15/11/2023 - Proclamação da República;</li>
<li>Dia 08/12/2023 - Dia da Justiça;</li>
<li>Dias 20/12/2023 a 31/12/2023 - Recesso Forense.</li>
</ul>
<p>Note que feriados que se sobrepõe ou que são aos finais de semana, só foram anotados uma vez, para evitar confusão. Note ainda que é trivial inserir as férias individuais de juízes e ministros desta forma.</p>
<p>Portanto, se fixado o ano, pode-se pensar no intervalo <span class="math inline">\((0,t]\)</span> como sendo o primeiro instante do primeiro dia do ano até o último instante do último dia do ano, podemos ordenar os dias por índice, tal que o primeiro dia do ano (1º de janeiro) representa o dia 1, o dia 1º de Fevereiro representa o dia 32, até o dia 31 de dezembro, representando o dia 365. O restante dos dias são dias úteis.</p>
<p>Com isso, teremos 134 dias que não são dias úteis no ano de 2023, sendo estes os dias de índice: 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 21, 22, 28, 29, 35, 36, 42, 43, 49, 50, 51, 52, 53, 56, 57, 63, 64, 70, 71, 77, 78, 84, 85, 91, 92, 95, 96, 97, 98, 99, 105, 106, 111, 112, 113, 119, 120, 121, 126, 127, 133, 134, 140, 141, 147, 148, 154, 155, 159, 161, 162, 168, 169, 175, 176, 182, 183, 189, 190, 196, 197, 203, 204, 210, 211, 217, 218, 223, 224, 225, 231, 232, 238, 239, 245, 246, 250, 252, 253, 259, 260, 266, 267, 273, 274, 280, 281, 285, 287, 288, 294, 295, 301, 302, 305, 306, 308, 309, 315, 316, 319, 322, 323, 329, 330, 336, 337, 342, 343, 344, 350, 351, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364 e 365. Iremos chamar o vetor que contém estes valores acima de <span class="math inline">\(\textbf{v}_{dnu}\)</span>, sendo seu complementar <span class="math inline">\(\textbf{v}_{du}\)</span> o vetor que contém todos os dias de 1 a 365 não contidos no vetor acima, representando assim os dias úteis (<span class="math inline">\(du\)</span>).</p>
</section>
<section id="processo-de-contagem" class="level2">
<h2 class="anchored" data-anchor-id="processo-de-contagem">Processo de contagem</h2>
<p>Um processo de contagem, definido por DINCER;DEMIR;YALÇIN (2022 apud BAS,2019) , é um processo estocástico, em que <span class="math inline">\(M(t),t \geq 0\)</span> é não negativo, com suporte em <span class="math inline">\(\mathbb{Z}\)</span> não decrescente <span class="math inline">\(\forall t \geq 0\)</span>. <span class="math inline">\(M(t)\)</span> é o número total de eventos que ocorrem até o tempo <span class="math inline">\(t\)</span>, e <span class="math inline">\(M(t,t+h)=M(t+h)-M(t)\)</span> denota o número de eventos ocorridos no intervalo <span class="math inline">\((t,t+h],h&gt;0\)</span>. Além disso, um processo de contagem, em que o número de eventos ocorridos em intervalos de tempo disjuntos são independentes e tem incrementos independentes. Um processo de contagem tem incrementos estacionários se a distribuição de <span class="math inline">\(M(t,t+h)\)</span> depende apenas do comprimento do intervalo de tempo.</p>
</section>
<section id="variável-aleatória-poisson" class="level2">
<h2 class="anchored" data-anchor-id="variável-aleatória-poisson">Variável aleatória Poisson</h2>
<p>Se <span class="math inline">\(M(t)\)</span> denota o número de eventos que ocorrem num intervalo de tempo específico, este é chamado variável aleatória Poisson. A variável aleatória Poisson possui função de massa de probabilidade:</p>
<p><span class="math display">\[\begin{equation}
    \mathbb{P}(M(t)=k)=\frac{e^{-\lambda_t}\lambda_t^k}{k!}
\end{equation}\]</span></p>
<p>onde <span class="math inline">\(\lambda_t\)</span> é o parâmetro da distribuição Poisson e representa a taxa de eventos que ocorrem no intervalo de tempo especificado, além de ser a variância e esperança de <span class="math inline">\(M(t)\)</span> ser igual a <span class="math inline">\(\lambda_t\)</span>.</p>
</section>
<section id="processo-de-poisson" class="level2">
<h2 class="anchored" data-anchor-id="processo-de-poisson">Processo de Poisson</h2>
<p>Um processo de Poisson é definido por ROSS(2010) como:</p>
<p><span class="math display">\[\begin{equation} \label{eq1}
N(t)  \stackrel{}{\sim} Poisson(m_(t)), i=1,2,...,n.
\end{equation}\]</span></p>
<p>E:</p>
<p><span class="math display">\[\begin{equation}
    \mathbb{P}\{N(t) = x\} = \frac{[m(t)]^{x}}{x!}e^{-m(t)}
\end{equation}\]</span></p>
<p>Onde <span class="math inline">\(\frac{o(h)}{h} \rightarrow 0, h \rightarrow 0\)</span></p>
<section id="processo-de-poisson-homogêneo" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-poisson-homogêneo">Processo de Poisson homogêneo</h3>
<p>Se o processo de Poisson <span class="math inline">\(M(t)\)</span> têm função de intensidade constante <span class="math inline">\(\lambda_t=\lambda \ \forall \ (t,t+s]\)</span>, então este é chamado um processo de Poisson homogêneo. (DINCER;DEMIR;YALÇIN,2022) </p>
</section>
<section id="processo-de-poisson-não-homogêneo" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-poisson-não-homogêneo">Processo de Poisson não homogêneo</h3>
<p>Se o processo de Poisson <span class="math inline">\(M(t)\)</span> tem função de intensidade variando com o tempo, este é um Processo de Poisson não homogêneo. A função massa de probabilidade deste processo é definida como:</p>
<p><span class="math display">\[\begin{equation}
    \mathbb{P}(M(t,t+h)=x)=\frac{\left( \int_t^{t+h}\lambda(z)dz \right)^x}{x!}e^{-\int_t^{t+h}\lambda(z)dz}
\end{equation}\]</span></p>
<div style="page-break-after: always;"></div>
</section>
</section>
</section>
<section id="análises" class="level1">
<h1>Análises</h1>
<p>Vamos supor que o número total de processos julgados em um período <span class="math inline">\(t\)</span> de tempo pelo <span class="math inline">\(i\)</span>-ésimo juiz ou ministro de um determinado tribunal <span class="math inline">\(N_{i}(t)\)</span> seja um processo de Poisson, definido por ROSS.</p>
<p>Em que <span class="math inline">\(n\)</span> seria o total de juízes e/ou ministros deste tribunal. Note que <span class="math inline">\(n\)</span> é determinístico, ou seja, escolhido um tribunal, este terá um número fixo de juízes e ou ministros. Portanto, <span class="math inline">\(n\)</span> <strong>não</strong> será tratado como variável aleatória neste estudo.</p>
<p>Com base nessas propriedades, temos que a probabilidade de o número de processos julgados pelo i-ésimo juiz ou ministro no tempo <span class="math inline">\((0,t]\)</span> ser exatamente x é dada por:</p>
<p><span class="math display">\[\begin{equation}
    \mathbb{P}\{N_{i}(t) = x\} = \frac{[m_{i}(t)]^{x}}{x!}e^{-m_{i}(t)}
\end{equation}\]</span></p>
<p>Podemos inferir empiricamente que a taxa <span class="math inline">\(m_i(t)\)</span> não é constante em relação ao tempo <span class="math inline">\(t\)</span>, sendo portanto uma função de <span class="math inline">\(t\)</span>, do tipo: <span class="math display">\[\begin{equation}
m_i(t) = E[N_{i}(t)]=\int_{0}^{t}\lambda_{i}(s)ds
\end{equation}\]</span> com função de intensidade <span class="math inline">\(\lambda_{i}(t)\)</span> e <span class="math inline">\(s\)</span> o intervalo <span class="math inline">\((t,t+s)\)</span>. Portanto, teremos: <span class="math display">\[\begin{equation}
    \mathbb{P}\{N_{i}(t) = x\} = \frac{1}{x!} \left( \int_{0}^{t}\lambda_i(x)dx \right) ^{n}exp \left( -\int_{0}^{t}\lambda_{i}(x)dx \right)
\end{equation}\]</span> Se considerarmos, por exemplo, que o número de processos que um juiz ou ministro julga em dias úteis terá intensidade diferente do número de processos que este juiz ou ministro julga em dias não úteis. Também sabemos empiricamente que o número de processos julgados em dias não úteis não é necessariamente sempre igual à zero, o que motiva a pensar que existem ao menos 2 intensidades possíveis, do tipo:</p>
<p><span class="math display">\[\begin{equation} \label{eq2}
\lambda_i(t) =
\begin{cases}
    \Lambda_{i(1)}\text{, Dia útil;} \\
    \Lambda_{i(2)}\text{, c.c.}
\end{cases}
\end{equation}\]</span></p>
<p>Constituindo portanto um processo de Poisson não homogêneo.</p>
<p>Da primeira equação, podemos inferir que o número total de processos julgados em um determinado tribunal é um processo de Poisson <span class="math inline">\(N(t)\)</span> composto, definido por:</p>
<p><span class="math display">\[\begin{equation} \label{eq0}
N(t) = \sum_{i=1}^{n} N_i(t) \stackrel{}{\sim} Poisson \left( m(t) \right)
\end{equation}\]</span> <span class="math display">\[\begin{equation}
\text{Em que} \ m(t) = \sum_{i=1}^{n}m_{i}(t)
\end{equation}\]</span> Constituindo portanto um processo de Poisson não homogêneo de n tempos.</p>
<p>Neste estudo, iremos estudar o tempo em dias. Ou seja, <span class="math inline">\(t=1\)</span> seria o tempo decorrido de meia noite (00:00:00) do dia 1º de Janeiro, até 23:59:59 do mesmo dia. Ou seja, <span class="math inline">\(t=1 \rightarrow (0,1]\)</span>.</p>
<p>Utilizando o definido na metodologia,, podemos redefinir a equação anterior mais precisamente como:</p>
<p><span class="math display">\[\begin{equation} \label{fi}
\lambda_i(t) =
\begin{cases}
    \Lambda_{i(1)}, \ \ \ \ \ t \in \textbf{v}_{du}, \\
    \Lambda_{i(2)}, \ \ \ \ \ t \in \textbf{v}_{dnu}, \\
\end{cases}
\end{equation}\]</span> Onde <span class="math inline">\(\Lambda_{i(1)}\)</span> e <span class="math inline">\(\Lambda_{i(2)}\)</span> são escalares, possíveis de serem estimados com dados do tribunal. É razoável conjecturar que <span class="math inline">\(\Lambda_{i(2)} \leq \Lambda_{i(1)}\)</span> no nosso exemplo. Com isso, estamos prontos para responder algumas perguntas.</p>
<section id="quantos-processos-são-julgados-por-um-juiz-em-um-mês" class="level2">
<h2 class="anchored" data-anchor-id="quantos-processos-são-julgados-por-um-juiz-em-um-mês">Quantos processos são julgados por um juiz em um mês?</h2>
<p>Tomando Janeiro de 2023 (dias 1 a 31) como exemplo, o número de processos julgados pelo i-ésimo juiz será uma variável aleatória Poisson, com média:</p>
<p><span class="math display">\[\begin{equation} \label{eq3}
\begin{split}
    \lambda_i\int_{t=0}^{t=31}\Lambda_i(s)ds \ ; \{s = 30\} \\
    = \lambda_i\int_{t=0}^{t=8}\Lambda_{i(2)}ds \\ + \ \lambda_i\int_{t=8}^{t=13}\Lambda_{i(1)}ds\\+ \ \lambda_i\int_{t=13}^{t=15}\Lambda_{i(2)}ds\\+ \ \lambda_i\int_{t=15}^{t=20}\Lambda_{i(1)}ds\\+ \ \lambda_i\int_{t=20}^{t=22}\Lambda_{i(2)}ds\\+ \ \lambda_i\int_{t=22}^{t=27}\Lambda_{i(1)}ds\\+ \ \lambda_i\int_{t=27}^{t=29}\Lambda_{i(2)}ds\\+ \ \lambda_i\int_{t=29}^{t=31}\Lambda_{i(1)}ds\\
\end{split}
\end{equation}\]</span></p>
<p>Note que podemos chamar uma variável <span class="math inline">\(z\)</span> para substituir <span class="math inline">\(t\)</span> nos limites de integração, afim de não precisar respeitar a ordenação dos dias e considerar apenas a passagem de tempo, tal que:</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
    t = i \rightarrow \text{i-ésimo dia} \\
    z = i \rightarrow \text{i-dias}
\end{cases}
\end{equation}\]</span></p>
<p>Portanto, teremos</p>
<p><span class="math display">\[\begin{equation} \label{eq4}
\begin{split}
    \lambda_i\int_{t=0}^{t=31}\lambda_i(s)ds &amp;= \lambda_i \left( \int_{z=0}^{z=17}\Lambda_{i(1)}ds \right) + \lambda_i \left( \int_{z=17}^{z=31}\Lambda_{i(2)}ds \right)\\
    &amp;= \lambda_i \left[ \left( \int_{z=0}^{z=17}\Lambda_{i(1)}ds \right)  + \left( \int_{z=17}^{z=31}\Lambda_{i(2)}ds \right) \right]
\end{split}
\end{equation}\]</span></p>
<div style="page-break-after: always;"></div>
</section>
<section id="quantos-processos-são-julgados-por-um-juíz-em-um-ano" class="level2">
<h2 class="anchored" data-anchor-id="quantos-processos-são-julgados-por-um-juíz-em-um-ano">Quantos processos são julgados por um juíz em um ano?</h2>
<p>Expandindo o raciocínio empregado anteriormente, podemos dizer que a quantidade de processos julgados pelo i-ésimo juiz no ano de 2023, com tempo <span class="math inline">\(t \in \textbf{v}_{du} \cup \textbf{v}_{dnu}\)</span> será Poisson com média:</p>
<p><span class="math display">\[\begin{equation} \label{eq5}
\begin{split}
    \lambda_i\int_{t=0}^{t=365}\lambda_i(s)ds
    &amp;= \lambda_i \left[ \left( \int_{z=0}^{z=231}\Lambda_{i(1)}ds \right)  + \left( \int_{z=231}^{z=365}\Lambda_{i(2)}ds \right) \right]
\end{split}
\end{equation}\]</span></p>
</section>
<section id="quantos-processos-são-julgados-em-um-tribunal-em-um-ano" class="level2">
<h2 class="anchored" data-anchor-id="quantos-processos-são-julgados-em-um-tribunal-em-um-ano">Quantos processos são julgados em um tribunal em um ano?</h2>
<p>Finalmente, podemos responder nossa pergunta inicial, aproveitando dos resultados das equações anteriores, temos que a quantidade de processos julgados em um tribunal (N(t=365)) será Poisson com média:</p>
<p><span class="math display">\[\begin{equation} \label{eq6}
\begin{split}
    N(t=365) = \sum_{i=1}^{n} \lambda_i \left[ \left( \int_{z=0}^{z=231}\Lambda_{i(1)}ds \right)  + \left( \int_{z=231}^{z=365}\Lambda_{i(2)}ds \right) \right]
\end{split}
\end{equation}\]</span></p>
</section>
</section>
<section id="aplicação-computacional" class="level1">
<h1>Aplicação computacional</h1>
<p>Íntegra dos códigos disponíveis em <a href="https://github.com/penasta/estocasticos/blob/main/rdocs/trabalho.R">Github</a>.</p>
</section>
<section id="resultados" class="level1">
<h1>Resultados</h1>
<p>Aplicando a teoria computacionalmente, utilizou-se dados de um determinado tribunal (STF), via dados públicos obtidos em <a href="https://transparencia.stf.jus.br/extensions/corte_aberta/corte_aberta.html">Corte aberta</a>. Escolhido o tribunal e o ano de 2023, delimitou-se também uma classe processual por entender que a classe também constitui fonte de variação na função de intensidade, o que não seria de interesse deste estudo, além de natureza não estocástica de algumas classes. Com isso, o resultado da pergunta “Quantos processos são julgados em um tribunal em um ano?” se especializa para “Quantos processos de classe HC foram julgados no STF em 2023?”, mudando portanto o parâmetro mas mantendo a ideia e intenção do estudo. Com isso, foi possível obter o seguinte gráfico:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="boxplot.png" class="img-fluid figure-img"></p>
<figcaption>Boxplot dos valores reais X simulados</figcaption>
</figure>
</div>
<table class="table">
<caption>Estatísticas encontradas X parâmetros</caption>
<thead>
<tr class="header">
<th>Estatística</th>
<th style="text-align: center;">Parâmetro</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E[(m(t)] = 84,56\)</span></td>
<td style="text-align: center;"><span class="math inline">\(m(t) = 131,4\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(E[N(t)] = 7.936,942\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N(t) = 12.221\)</span></td>
</tr>
</tbody>
</table>
<p>Em que observamos que o número estimado pelo processo foi de uma grandeza razoavelmente conservadora em relação ao número real de processos.</p>
</section>
<section id="conclusão" class="level1">
<h1>Conclusão</h1>
<p>Das análises contidas na seção 4, baseadas na metodologia da seção 3, foi possível modelar o problema com suporte matemático, em que usando destas definições poderíamos retirar conclusões e respostas pertinentes a problemas reais.</p>
<p>Com a aplicação computacional executada na seção 5, podemos testar se, delimitado um escopo e com algumas limitações, as propriedades escritas funcionariam empiricamente. Conforme observado, a função de intensidade proposta na aplicação (1 para <span class="math inline">\(v_{du}\)</span>; 0 para <span class="math inline">\(v_{dnu}\)</span>) não foi eficiente em descrever bem o comportamento do processo. O ideal seria numa aplicação futura estimar de outra maneira esta função de intensidade. Uma possibilidade é que esta função seja específica para cada juiz, visto que pode ocorrer de alguns continuarem produzindo normalmente em férias, enquanto outros optam por descansar. É ainda interessante adicionar as férias individuais de cada um dos no vetor <span class="math inline">\(v_{dnu}\)</span> individual, para melhorar ainda mais as estimativas. DINCER;DEMIR;YALÇIN(2022, p.1148) propõe ainda alguns modelos pré calibrados para a função de intensidade, que poderiam ser testados também.</p>
<p>Podemos ver na aplicação, entretanto, que o tempo e o juiz foram fatores que influenciavam na contagem, corroborando com o postulado de que este seria um processo de Poisson não homogêneo de n tipos. Vimos ainda que sob a hipótese nula de das duas últimas equações, o teste de Kolmogorov-Smirnov não rejeitou a distribuição hipotetizada para alguns dos testes.</p>
<p>Voltando a pergunta primeiramente formulada, “Quantos processos são julgados em um tribunal em um ano?”. De ROSS (p.&nbsp;342), temos que: <span class="math display">\[\begin{equation}
    E[N(t)] = \lambda \int_0^t\frac{\lambda(y)}{\lambda}dy = \int_0^t\lambda(y)dy
\end{equation}\]</span> Que, no nosso exemplo empírico, resultou em 7.936,942 para uma determinada semente; onde dados analíticos mostram que o verdadeiro valor era de 12.221. Calibrada a função de intensidade (pelo que o resultado numérico mostra, a estimativa está conservadora), pode-se por este método chegar mais próximo ao verdadeiro parâmetro.</p>
<p>Portanto, conclui-se que este pode ser um instrumento útil para modelagem probabilística de questões de contagem em tribunais.</p>
<section id="referências" class="level2">
<h2 class="anchored" data-anchor-id="referências">Referências</h2>
<ul>
<li>Ross, S. M. (2010). Introduction to Probability Models. Academic Press.</li>
<li>Dincer, E., Demir, S. M., &amp; Yalçın, B. A. (2022). [Título do artigo]. [Nome da Revista/Congresso].</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/penasta\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>MIT License 2024, Bruno Gondim.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>